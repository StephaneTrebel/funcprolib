{"version":3,"sources":["../src/maybe.js"],"names":["createMaybe","input","newMaybe","isMaybe","of","Number","isNaN","value","hasNothing","map","toString","isNothing","fn","err","orElse","maybeFlow","fns","applier","reduce","prev","curr","errorFn"],"mappings":";;;;;;;AAAA;;AAOA,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AACxB,QAAMC,WAAW,EAAjB;AACAA,aAASC,OAAT,GAAmB,IAAnB;AACAD,aAASE,EAAT,GAAc,UAASH,KAAT,EAAgB;AAC1B,YAAIA,SAASA,MAAME,OAAnB,EAA4B;AACxB,mBAAOF,KAAP;AACH;AACD,YAAI,iBAAQA,KAAR,KAAkB,gBAAOA,KAAP,CAAlB,IAAmCI,OAAOC,KAAP,CAAaL,KAAb,CAAnC,IAA0D,qBAAYA,KAAZ,CAA9D,EAAkF;AAC9EC,qBAASK,KAAT,GAAiBN,KAAjB;AACAC,qBAASM,UAAT,GAAsB,IAAtB;AACA,mBAAON,QAAP;AACH;AACD,YAAI,oBAAWD,KAAX,CAAJ,EAAuB;AACnB,mBAAOC,SAASO,GAAT,CAAaR,KAAb,CAAP;AACH;AACDC,iBAASK,KAAT,GAAiBN,KAAjB;AACA,eAAOC,QAAP;AACH,KAdD;AAeAA,aAASQ,QAAT,GAAoB;AAAA,2BAAeR,SAASS,SAAT,KAAuB,SAAvB,GAAmCT,SAASK,KAA3D;AAAA,KAApB;AACAL,aAASS,SAAT,GAAqB;AAAA,eAAM,CAAC,CAACT,SAASM,UAAjB;AAAA,KAArB;AACAN,aAASO,GAAT,GAAe,UAASG,EAAT,EAAa;AACxB,YAAIV,SAASS,SAAT,EAAJ,EAA0B;AACtB,mBAAOT,QAAP;AACH;AACD,YAAI;AACA,mBAAOF,YAAYY,GAAGV,SAASK,KAAZ,CAAZ,CAAP;AACH,SAFD,CAEE,OAAOM,GAAP,EAAY;AACV,mBAAOb,YAAYa,GAAZ,CAAP;AACH;AACJ,KATD;AAUAX,aAASY,MAAT,GAAkB,UAASb,KAAT,EAAgB;AAC9B,YAAIC,SAASS,SAAT,EAAJ,EAA0B;AACtB,gBAAI,oBAAWV,KAAX,CAAJ,EAAuB;AACnB,uBAAOA,OAAP;AACH;AACD,mBAAOA,KAAP;AACH;AACD,eAAOC,SAASK,KAAhB;AACH,KARD;AASA,WAAOL,SAASE,EAAT,CAAYH,KAAZ,CAAP;AACH;;AAED,SAASc,SAAT,GAA2B;AAAA,sCAALC,GAAK;AAALA,WAAK;AAAA;;AACvB,QAAMC,UAAU,SAAVA,OAAU,CAAChB,KAAD;AAAA,eAAWe,IAAIE,MAAJ,CACvB,UAACC,IAAD,EAAOC,IAAP;AAAA,mBAAgBD,KAAKV,GAAL,CAASW,IAAT,CAAhB;AAAA,SADuB,EACSpB,YAAYC,KAAZ,CADT,CAAX;AAAA,KAAhB;AAGAgB,YAAQH,MAAR,GAAiB,UAACO,OAAD;AAAA,eAAa,UAACpB,KAAD;AAAA,mBAAWgB,QAAQhB,KAAR,EAAea,MAAf,CAAsBO,OAAtB,CAAX;AAAA,SAAb;AAAA,KAAjB;AACA,WAAOJ,OAAP;AACH;;QAGGjB,W,GAAAA,W;QACAe,S,GAAAA,S","file":"maybe.js","sourcesContent":["import {\n    isError,\n    isFunction,\n    isNull,\n    isUndefined\n} from \"lodash/fp\";\n\nfunction createMaybe(input) {\n    const newMaybe = {};\n    newMaybe.isMaybe = true;\n    newMaybe.of = function(input) {\n        if (input && input.isMaybe) {\n            return input;\n        }\n        if (isError(input) || isNull(input) || Number.isNaN(input) || isUndefined(input)) {\n            newMaybe.value = input;\n            newMaybe.hasNothing = true;\n            return newMaybe;\n        }\n        if (isFunction(input)) {\n            return newMaybe.map(input);\n        }\n        newMaybe.value = input;\n        return newMaybe;\n    };\n    newMaybe.toString = () => `Maybe(${newMaybe.isNothing() ? \"Nothing\" : newMaybe.value})`;\n    newMaybe.isNothing = () => !!newMaybe.hasNothing;\n    newMaybe.map = function(fn) {\n        if (newMaybe.isNothing()) {\n            return newMaybe;\n        }\n        try {\n            return createMaybe(fn(newMaybe.value));\n        } catch (err) {\n            return createMaybe(err);\n        }\n    };\n    newMaybe.orElse = function(input) {\n        if (newMaybe.isNothing()) {\n            if (isFunction(input)) {\n                return input();\n            }\n            return input;\n        }\n        return newMaybe.value;\n    };\n    return newMaybe.of(input);\n}\n\nfunction maybeFlow(...fns) {\n    const applier = (input) => fns.reduce(\n        (prev, curr) => prev.map(curr), createMaybe(input)\n    );\n    applier.orElse = (errorFn) => (input) => applier(input).orElse(errorFn);\n    return applier;\n}\n\nexport {\n    createMaybe,\n    maybeFlow\n};\n"]}