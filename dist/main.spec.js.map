{"version":3,"sources":["../src/main.spec.js"],"names":["name","assertions","when","should","test","t","monad","createErroneousMonad","a","equal","isMonad","end","plan","c","undefined","NaN","Error","createSuccessfulMonad","monadDefinition","getSuccessfulValue","isInErrorState","pass","toString","map","fail","x","m","newMonad","s","err","b","chain","getErroneousValue","e","message","applier","debug","throwFnHO","idFn","includes"],"mappings":"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","file":"main.spec.js","sourcesContent":["import {\n    executeTests,\n    utilityFunctions\n} from \"../tests/unit-tests.js\";\n\nimport {\n    createMonad,\n    flow\n} from \"./main\";\n\nexecuteTests(\"Main export\", [{\n    name: \"createMonad - Creating a Monad\",\n    assertions: [{\n        when: \"called without any input\",\n        should: \"return an erroneous Monad\",\n        test: (test) => test(function(t) {\n            const monad = createMonad({\n                createErroneousMonad: () => ({\n                    a: true\n                })\n            })();\n            t.equal(monad.isMonad, true);\n            t.equal(monad.a, true);\n            t.end();\n        })\n    }, {\n        when: \"called with any falsy type\",\n        should: \"return an erroneous Monad\",\n        test: (test) => test(function(t) {\n            t.plan(4);\n            const c = createMonad({\n                createErroneousMonad: () => ({\n                    a: true\n                })\n            });\n            t.equal(c(null).isMonad, c(null).a);\n            t.equal(c(undefined).isMonad, c(undefined).a);\n            t.equal(c(NaN).isMonad, c(NaN).a);\n            t.equal(c(new Error(\"DERP\")).isMonad, c(new Error(\"DERP\")).a);\n            t.end();\n        })\n    }, {\n        when: \"called with any non-null type\",\n        should: \"return a non-erroneous Monad\",\n        test: (test) => test(function(t) {\n            t.plan(4);\n            const c = createMonad({\n                createSuccessfulMonad: () => ({\n                    a: true\n                })\n            });\n            t.equal(c(\"foo\").isMonad, c(\"foo\").a);\n            t.equal(c(123).isMonad, c(123).a);\n            t.equal(c([]).isMonad, c([]).a);\n            t.equal(c({}).isMonad, c({}).a);\n            t.end();\n        })\n    }, {\n        when: \"called with a Monad\",\n        should: \"return the same Monad\",\n        test: (test) => test(function(t) {\n            const monad = {\n                isMonad: true\n            };\n            // Same reference check\n            t.equal(\n                createMonad()(monad),\n                monad\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a Function\",\n        should: \"return a function that takes a regular value and returns a new Monad on which given function will have been applied\",\n        test: (test) => test(function(t) {\n            t.plan(1);\n            const monadDefinition = {\n                createSuccessfulMonad: () => ({}),\n                createErroneousMonad: () => ({}),\n                getSuccessfulValue: () => \"ok\",\n                isInErrorState: () => false\n            };\n            createMonad(monadDefinition)(t.pass)(\"foo\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"createMonad - Using a created Monad\",\n    assertions: [{\n        when: \"...everytime\",\n        should: \"have a toString method\",\n        test: (test) => test(function(t) {\n            t.equal(\n                typeof createMonad({\n                    createErroneousMonad: () => ({})\n                })().toString,\n                \"function\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"an erroneous Monad has its map method called with any function\",\n        should: \"return the same Monad without invoking the mapping function\",\n        test: (test) => test(function(t) {\n            const monad = createMonad({\n                createErroneousMonad: () => ({}),\n                isInErrorState: () => true\n            })();\n            t.equal(\n                monad.map(t.fail),\n                monad\n            );\n            t.end();\n        })\n    }, {\n        when: \"a successful Monad has its map method called with any function that won't thow\",\n        should: \"return a new successful Monad wrapping the application result of given function onto its internal value\",\n        test: (test) => test(function(t) {\n            const monad = createMonad({\n                createSuccessfulMonad: (x) => ({\n                    a: x\n                }),\n                createErroneousMonad: t.fail,\n                getSuccessfulValue: (m) => m && m.a,\n                isInErrorState: () => false\n            })(\"foo\");\n            const newMonad = monad.map((s) => s + \"bar\");\n            t.equal(newMonad.isMonad, true, \"Result is a Monad\");\n            t.equal(newMonad === monad, false, \"A different Monad instance\");\n            t.equal(newMonad.a, \"foobar\", \"Its content is the function application\");\n            t.end();\n        })\n    }, {\n        when: \"a successful Monad has its map method called with any throwing function\",\n        should: \"return a new erroneous Monad\",\n        test: (test) => test(function(t) {\n            const err = new Error(\"DERP\");\n            const monad = createMonad({\n                createSuccessfulMonad: (x) => ({\n                    a: x\n                }),\n                createErroneousMonad: (x) => ({\n                    b: x\n                }),\n                getSuccessfulValue: (m) => m && m.a,\n                isInErrorState: (m) => !!m.b\n            })(\"foo\");\n            const newMonad = monad.map(function() {\n                throw err;\n            });\n            t.equal(newMonad.isMonad, true, \"Result is a Monad\");\n            t.equal(newMonad === monad, false, \"A different Monad instance\");\n            t.equal(!!newMonad.b, true, \"Resulting Monad is an erroneous Monad\");\n            t.end();\n        })\n    }, {\n        when: \"a successful Monad has its chain method called, regardless of given input\",\n        should: \"return the Monad internal value\",\n        test: (test) => test(function(t) {\n            const monad = createMonad({\n                createSuccessfulMonad: (x) => ({\n                    a: x\n                }),\n                getSuccessfulValue: (m) => m && m.a,\n                isInErrorState: (m) => !m.a\n            })(\"foo\");\n            t.equal(\n                monad.chain(t.fail),\n                \"foo\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"an erroneous Monad has its chain method called with a function\",\n        should: \"return the application of given function on the Monad internal value\",\n        test: (test) => test(function(t) {\n            const err = new Error(\"DERP\");\n            const monad = createMonad({\n                createErroneousMonad: (x) => ({\n                    b: x\n                }),\n                getErroneousValue: (m) => m && m.b,\n                isInErrorState: (m) => !!m.b\n            })(err);\n            t.equal(\n                monad.chain((e) => e.message + \"foo\"),\n                \"DERPfoo\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"an erroneous Monad has its chain method called with anything else than function\",\n        should: \"return the given input\",\n        test: (test) => test(function(t) {\n            const err = new Error(\"DERP\");\n            const monad = createMonad({\n                createErroneousMonad: (x) => ({\n                    b: x\n                }),\n                isInErrorState: (m) => !!m.b\n            })(err);\n            t.equal(\n                monad.chain(\"foo\"),\n                \"foo\"\n            );\n            t.end();\n        })\n    }]\n}, {\n    name: \"flow()\",\n    assertions: [{\n        when: \"called with no function list\",\n        should: \"return a function that returns a Monad\",\n        test: (test) => test(function(t) {\n            t.equal(\n                flow({\n                    createErroneousMonad: () => ({})\n                })()().isMonad,\n                true\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a function list\",\n        should: \"return a function that will apply all functions of given list on a given Monad\",\n        test: (test) => test(function(t) {\n            t.equal(\n                flow({\n                    createSuccessfulMonad: (x) => ({\n                        a: x\n                    }),\n                    getSuccessfulValue: (m) => m && m.a,\n                    isInErrorState: (m) => !!m.b\n                })(\n                    (a) => a + \"bar\",\n                    (b) => b + \"qux\"\n                )(\"foo\").chain(),\n                \"foobarqux\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a function list\",\n        should: \"return a function that has a chain property which is a shortcut to the resulting Monad.chain method\",\n        test: (test) => test(function(t) {\n            const applier = flow({\n                createSuccessfulMonad: (x) => ({\n                    a: x\n                }),\n                getSuccessfulValue: (m) => m && m.a,\n                isInErrorState: (m) => !!m.b\n            })(\n                (a) => a + \"bar\",\n                (b) => b + \"qux\"\n            ).chain();\n            t.equal(\n                applier(\"foo\"),\n                \"foobarqux\"\n            );\n            t.end();\n        })\n    }]\n}, {\n    name: \"flow.debug()\",\n    assertions: [{\n        when: \"called with no function list\",\n        should: \"return a function that returns a Monad\",\n        test: (test) => test(function(t) {\n            t.equal(\n                flow({\n                    createErroneousMonad: () => ({})\n                })()().isMonad,\n                true\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a function list\",\n        should: \"return a function that will apply all functions of given list on a given Monad\",\n        test: (test) => test(function(t) {\n            t.equal(\n                flow({\n                    createSuccessfulMonad: (x) => ({\n                        a: x\n                    }),\n                    getSuccessfulValue: (m) => m && m.a,\n                    isInErrorState: (m) => !!m.b\n                })(\n                    (a) => a + \"bar\",\n                    (b) => b + \"qux\"\n                )(\"foo\").chain(),\n                \"foobarqux\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a function list\",\n        should: \"return a function that will ignore all subsequent function calls upon encountering an erroneous Monad\",\n        test: (test) => test(function(t) {\n            t.equal(\n                flow.debug({\n                    createSuccessfulMonad: (x) => ({\n                        a: x\n                    }),\n                    createErroneousMonad: (x) => ({\n                        b: x\n                    }),\n                    getSuccessfulValue: (m) => m && m.a,\n                    getErroneousValue: (m) => m && m.b,\n                    isInErrorState: (m) => !!m.b\n                })(\n                    (a) => a + \"bar\",\n                    utilityFunctions.throwFnHO(\"DERP\"),\n                    // istanbul ignore next\n                    (b) => b + \"qux\"\n                )(\"foo\").chain(utilityFunctions.idFn).message.includes(\"DERP\"),\n                true\n            );\n            t.end();\n        })\n    }, {\n        when: \"called with a function list\",\n        should: \"return a function that has an chain property which is a shortcut to the resulting Monad.chain method\",\n        test: (test) => test(function(t) {\n            const applier = flow.debug({\n                createSuccessfulMonad: (x) => ({\n                    a: x\n                }),\n                getSuccessfulValue: (m) => m && m.a,\n                isInErrorState: (m) => !!m.b\n            })(\n                (a) => a + \"bar\",\n                (b) => b + \"qux\"\n            ).chain();\n            t.equal(\n                applier(\"foo\"),\n                \"foobarqux\"\n            );\n            t.end();\n        })\n    }]\n}]);\n"]}