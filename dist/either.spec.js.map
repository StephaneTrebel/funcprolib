{"version":3,"sources":["../src/either.spec.js"],"names":["createErroneousMonad","createSuccessfulMonad","getErroneousValue","getSuccessfulValue","isInErrorState","toString","name","assertions","when","should","test","t","either","Error","equal","hasLeft","left","includes","end","testInput","input","msg","deepEqual","foo","qux","right"],"mappings":"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","file":"either.spec.js","sourcesContent":["import {\n    executeTests\n} from \"../tests/unit-tests.js\";\n\nimport eitherDefinition from \"./either\";\n\nconst {\n    createErroneousMonad,\n    createSuccessfulMonad,\n    getErroneousValue,\n    getSuccessfulValue,\n    isInErrorState,\n    toString\n} = eitherDefinition;\n\nexecuteTests(\"Either Monad definition\", [{\n    name: \"createErroneousMonad()\",\n    assertions: [{\n        when: \"called with an Error\",\n        should: \"return an Either(Left)\",\n        test: (test) => test(function(t) {\n            const either = createErroneousMonad(new Error(\"DERP\"));\n            t.equal(either.hasLeft, true, \"It has a Left value\");\n            t.equal(either.left.includes(\"DERP\"), true, \"Left value includes the error message\");\n            t.end();\n        })\n    }, {\n        when: \"called with anything else than an Error\",\n        should: \"return an Either(Left)\",\n        test: (test) => test(function(t) {\n            const testInput = function(input, msg) {\n                const either = createErroneousMonad(input);\n                t.deepEqual(either.hasLeft, true, `It has a Left value for ${msg}`);\n                t.deepEqual(either.left, input, `Ok for ${msg}`);\n            };\n            testInput(\"foo\", \"Strings\");\n            testInput(123, \"Numbers\");\n            testInput({}, \"empty Objects\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\"\n            }, \"non-empty Objects\");\n            testInput([], \"empty Arrays\");\n            testInput([\"foo\", \"bar\", \"qux\"], \"non-empty Arrays\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"createSuccessfulMonad()\",\n    assertions: [{\n        when: \"...everytime\",\n        should: \"return an Either(Right) with given input as internal value\",\n        test: (test) => test(function(t) {\n            const testInput = function(input, msg) {\n                const either = createSuccessfulMonad(input);\n                t.deepEqual(!!either.hasLeft, false, `It has a Right value for ${msg}`);\n                t.deepEqual(either.right, input, `Ok for ${msg}`);\n            };\n            testInput(\"foo\", \"Strings\");\n            testInput(123, \"Numbers\");\n            testInput({}, \"empty Objects\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\"\n            }, \"non-empty Objects\");\n            testInput([], \"empty Arrays\");\n            testInput([\"foo\", \"bar\", \"qux\"], \"non-empty Arrays\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"getErroneousValue()\",\n    assertions: [{\n        when: \"given any Either(Left)\",\n        should: \"return input left value\",\n        test: (test) => test(function(t) {\n            const testInput = (input, msg) => t.deepEqual(\n                getErroneousValue(createErroneousMonad(input)), input, `Ok for ${msg}`\n            );\n            testInput(\"foo\", \"Strings\");\n            testInput(123, \"Numbers\");\n            testInput({}, \"empty Objects\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\"\n            }, \"non-empty Objects\");\n            testInput([], \"empty Arrays\");\n            testInput([\"foo\", \"bar\", \"qux\"], \"non-empty Arrays\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"getSuccessfulValue()\",\n    assertions: [{\n        when: \"given any Either(Right)\",\n        should: \"return input right value\",\n        test: (test) => test(function(t) {\n            const testInput = (input, msg) => t.deepEqual(\n                getSuccessfulValue(createSuccessfulMonad(input)), input, `Ok for ${msg}`\n            );\n            testInput(\"foo\", \"Strings\");\n            testInput(123, \"Numbers\");\n            testInput({}, \"empty Objects\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\"\n            }, \"non-empty Objects\");\n            testInput([], \"empty Arrays\");\n            testInput([\"foo\", \"bar\", \"qux\"], \"non-empty Arrays\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"isInErrorState()\",\n    assertions: [{\n        when: \"given any Either(Right)\",\n        should: \"return false\",\n        test: (test) => test(function(t) {\n            const testInput = (input, msg) => t.deepEqual(\n                isInErrorState(createSuccessfulMonad(input)), false, `Ok for ${msg}`\n            );\n            testInput(\"foo\", \"Strings\");\n            testInput(123, \"Numbers\");\n            testInput({}, \"empty Objects\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\"\n            }, \"non-empty Objects, without an hasLeft property\");\n            testInput({\n                foo: \"bar\",\n                qux: \"baz\",\n                hasLeft: false\n            }, \"non-empty Objects, with a falsy hasLeft property\");\n            testInput([], \"empty Arrays\");\n            testInput([\"foo\", \"bar\", \"qux\"], \"non-empty Arrays\");\n            t.end();\n        })\n    }, {\n        when: \"given any Either(Left)\",\n        should: \"return true\",\n        test: (test) => test(function(t) {\n            const testInput = (input, msg) => t.deepEqual(\n                isInErrorState(createErroneousMonad(input)), true, `Ok for ${msg}`\n            );\n            testInput(new Error(\"DERP\"), \"Errors\");\n            testInput({\n                foo: \"bar\",\n                hasLeft: true\n            }, \"Objects forcibly having a truthy hasLeft property\");\n            t.end();\n        })\n    }]\n}, {\n    name: \"toString()\",\n    assertions: [{\n        when: \"given any Either(Right)\",\n        should: \"return a String stating the Monad is an Either(Right)\",\n        test: (test) => test(function(t) {\n            const either = createSuccessfulMonad(\"foo\");\n            t.equal(\n                toString(either).includes(\"Either\"), true,\n                \"it states that given input is an Either\"\n            );\n            t.equal(\n                toString(either).includes(\"Right\"), true,\n                \"it states that given input is an Either(Right)\"\n            );\n            t.end();\n        })\n    }, {\n        when: \"given any Either(Left)\",\n        should: \"return a String stating the Monad is an Either(Left)\",\n        test: (test) => test(function(t) {\n            const either = createErroneousMonad(\"foo\");\n            t.equal(\n                toString(either).includes(\"Either\"), true,\n                \"it states that given input is an Either\"\n            );\n            t.equal(\n                toString(either).includes(\"Left\"), true,\n                \"it states that given input is an Either(Left)\"\n            );\n            t.end();\n        })\n    }]\n}]);\n"]}