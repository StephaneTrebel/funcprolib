{"version":3,"sources":["../src/main.js"],"names":["createMonad","flow","monadDefinition","input","isMonad","a","map","newMonad","Number","isNaN","createErroneousMonad","createSuccessfulMonad","toString","fn","isInErrorState","getSuccessfulValue","err","chain","getErroneousValue","fns","applier","reduce","prev","curr","errorFn","debug","functionCall","temp","console","log","split","createEither","eitherFlow","createMaybe","maybeFlow"],"mappings":"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","file":"main.js","sourcesContent":["import {\n    isError,\n    isFunction,\n    isNull,\n    isUndefined\n} from \"lodash/fp\";\n\nimport eitherDefinition from \"./either\";\n\nimport maybeDefinition from \"./maybe\";\n\nexport function createMonad(monadDefinition) {\n    return function(input) {\n        // @note Handle different Monad types here ? E.g Either(Maybe())\n        if (input && input.isMonad) {\n            return input;\n        }\n        if (isFunction(input)) {\n            return (a) => createMonad(monadDefinition)(a).map(input);\n        }\n\n        const newMonad = (isError(input) || isNull(input) || Number.isNaN(input) || isUndefined(input)) ?\n            monadDefinition.createErroneousMonad(input) :\n            monadDefinition.createSuccessfulMonad(input);\n        newMonad.isMonad = true;\n        newMonad.toString = () => monadDefinition.toString(newMonad);\n\n        /**\n         * Apply a function on a monad value, but only if the monad is in an ok\n         * state\n         * @param {Function} fn - Function to apply\n         * @return {Object} If everything went right, a new monad with the\n         * result of calling given function with the monad value, or the same\n         * monad, untouched\n         **/\n        newMonad.map = function(fn) {\n            try {\n                if (monadDefinition.isInErrorState(newMonad)) {\n                    return newMonad;\n                }\n                return createMonad(monadDefinition)(\n                    fn(monadDefinition.getSuccessfulValue(newMonad))\n                );\n            } catch (err) {\n                return createMonad(monadDefinition)(err);\n            }\n        };\n\n        /**\n         * Apply a function on a monad erroneous value, or just return the\n         * monad right value\n         * @node Should be improved to apply given function on right value too\n         * @param {Function} fn - Function to apply\n         * @return {Object} If everything went right the monad value, or the\n         * result of calling the function with the monad's erroneous value\n         **/\n        newMonad.chain = function(input) {\n            if (monadDefinition.isInErrorState(newMonad)) {\n                if (isFunction(input)) {\n                    return input(monadDefinition.getErroneousValue(newMonad));\n                }\n                return input;\n            }\n            // @note According to fantasyland specs, we should apply input on\n            // the monad value, even if it's not in an erroneous state\n            return monadDefinition.getSuccessfulValue(newMonad);\n        };\n\n        return newMonad;\n    };\n}\n\n/**\n * Create a monad out of given input and map any number of functions\n * on it\n * @param {Object} monadDefinition - Monad definition\n * @param {Array<Function>} fns - Functions to apply on the new monad\n * @return {Object} A new Monad on which all given functions will\n * have been called\n **/\nexport function flow(monadDefinition) {\n    return function(...fns) {\n        const applier = (input) => fns.reduce(\n            (prev, curr) => prev.map(curr), createMonad(monadDefinition)(input)\n        );\n        applier.chain = (errorFn) => (input) => applier(input).chain(errorFn);\n        return applier;\n    };\n}\n\n/**\n * Debug version of flow\n * @node Merge with regular flow\n * @param {Object} monadDefinition - Monad definition\n * @param {Array<Function>} fns - Functions to apply on the new monad\n * @return {Object} A new Monad on which all given functions will\n * have been called\n **/\nflow.debug = function(monadDefinition) {\n    return function(...fns) {\n        let functionCall = 0;\n        const applier = (input) => fns.reduce(\n            function(prev, curr) {\n                const debug = \"FuncProLib Debug - \";\n                const temp = prev.map(curr);\n                if (prev.chain()) {\n                    console.log(debug + \"Monad is in an erroneous state. Bypassing \", curr.toString().split(\"\\n\")[0]);\n                } else {\n                    functionCall = functionCall + 1;\n                    console.log(`${debug}Call #${functionCall}`);\n                    console.log(`${debug}Current value=${prev.toString()}`);\n                    console.log(`${debug}Next function=${curr}`);\n                    console.log(`${debug}New value=${temp.toString()}`);\n                }\n                return temp;\n            }, createMonad(monadDefinition)(input)\n        );\n        applier.chain = (errorFn) => (input) => applier(input).chain(errorFn);\n        return applier;\n    };\n};\n\n// @note Merge into one export const when JSLint accepts it (someday ?)\nconst createEither = createMonad(eitherDefinition);\nconst eitherFlow = flow(eitherDefinition);\neitherFlow.debug = flow.debug(eitherDefinition);\n\nconst createMaybe = createMonad(maybeDefinition);\nconst maybeFlow = flow(maybeDefinition);\nmaybeFlow.debug = flow.debug(maybeDefinition);\n\nexport {\n    createEither,\n    eitherFlow,\n    createMaybe,\n    maybeFlow\n};\n"]}